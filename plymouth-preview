#!/usr/bin/env python3
"""
Utility script to make testing plymouth themes easier by emulating the boot
process and ensuring that it actually stops!
"""

from __future__ import annotations

__author__ = "Lexi Robinson <lexi@lexi.org.uk>"
__copyright__ = "Copyright 2025 Lexi Robinson"
__license__ = "GPL-3.0-or-later"
__version__ = "0.0.0"

import argparse
import asyncio
import logging
import os
from asyncio import subprocess

logger = logging.getLogger("plymouth-preview")


def main() -> None:
    args = _setup_args()
    _setup_logging(args.log_level)
    _check_root()

    asyncio.run(_async_main(args))


async def _run_program_bad(name: str, *args: str) -> None:
    logger.info("Running %s %s", name, args)
    await (
        await subprocess.create_subprocess_exec(
            name,
            *args,
            stdin=None,
            stdout=None,
            stderr=None,
        )
    ).wait()


async def _async_main(args: Args):
    # basic pass for now
    await _run_program_bad("plymouthd")
    await _run_program_bad("plymouth", "--show-splash")
    for i in range(args.duration):
        await _run_program_bad("plymouth", f"--update=test{i}")
        await asyncio.sleep(1)
    await _run_program_bad("plymouth", "--quit")


def _check_root():
    if os.geteuid() != 0:
        logger.critical("Cannot work without effective root!")
        exit(1)


class Args(argparse.Namespace):
    duration: int
    log_level: str


def _positive_integer(raw: str) -> int:
    value = int(raw)
    if value <= 0:
        raise ValueError(f"Invalid value {raw}")
    return value


def _setup_args() -> Args:
    parser = argparse.ArgumentParser(
        "plymouth-preview",
        description=__doc__,
        epilog="NOTE: You must run this program as root!",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "duration",
        type=_positive_integer,
        nargs="?",
        default=10,
        help="Number of seconds to display the splash screen",
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        type=lambda s: s.upper(),
        choices=["DEBUG", "INFO", "WARN", "ERROR"],
        help="Set the minimum logging level",
    )

    return parser.parse_args(namespace=Args())


def _setup_logging(level: str) -> None:
    logging.basicConfig(
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S",  # remove milliseconds
        level=level,
    )


if __name__ == "__main__":
    main()
