#!/usr/bin/env python3
"""
Utility script to make testing plymouth themes easier by emulating the boot
process and ensuring that it actually stops!
"""

from __future__ import annotations

__author__ = "Lexi Robinson <lexi@lexi.org.uk>"
__copyright__ = "Copyright 2025 Lexi Robinson"
__license__ = "GPL-3.0-or-later"
__version__ = "0.0.0"

import argparse
import asyncio
import logging
import os
from asyncio import streams, subprocess

logger = logging.getLogger("plymouth-preview")

STARTUP_TIMEOUT = 2
SHUTDOWN_TIMEOUT = 2


def main() -> None:
    args = _setup_args()
    _setup_logging(args.log_level)
    _check_root()

    asyncio.run(_async_main(args))


async def _async_main(args: Args):
    plymouthd = await _launch_plymouthd(args)
    try:
        if not await _launch_and_run("plymouth", "--show-splash"):
            logger.error("Failed to launch the splash!")
            return
        match args.mode:
            case "startup":
                await _main_startup(args)
            case "shutdown" | "reboot":
                await _main_shutdown(args)
            case "updates" | "system-upgrade" | "firmware-upgrade" | "system-reset":
                await _main_updates(args)
            case what:
                logger.error("Unknown mode %s", what)
                return
    finally:
        if plymouthd.returncode is not None:
            return

        async def _shutdown():
            shutdown = await _launch_program(
                "plymouth",
                "--quit",
                capture_logs=False,
            )
            await shutdown.wait()
            await plymouthd.wait()

        try:
            logger.info("Waiting for plymouthd to shut down")
            await asyncio.wait_for(_shutdown(), timeout=SHUTDOWN_TIMEOUT)
        except TimeoutError:
            logger.error("Timed out waiting for shutdown!")
            plymouthd.kill()


async def _main_startup(args: Args):
    ask_question = args.ask_question
    ask_password = args.ask_password
    for i in range(args.duration):
        if not await _launch_and_run("plymouth", f"--update=test{i}"):
            logger.error("Failed to run update - did plymouth crash?")
            return
        await asyncio.sleep(1)
        # Ask after the first second
        if ask_question is not None:
            if not await _ask_question(
                "ask-question",
                "What is the answer?",
                ask_question,
            ):
                logger.error("Failed to ask a question- did plymouth crash?")
                return
            ask_question = None
        if ask_password is not None:
            if not await _ask_question(
                "ask-for-password",
                "What is the password?",
                ask_password,
            ):
                logger.error("Failed to ask a question- did plymouth crash?")
                return
            ask_password = None


async def _main_shutdown(args: Args):
    for i in range(args.duration):
        if not await _launch_and_run(
            "plymouth",
            "update",
            f"--status={args.mode}: {i}",
        ):
            logger.error("Failed to talk to Plymouth, did it crash?")
            return
        await asyncio.sleep(1)


async def _main_updates(args: Args):
    sleep_amount = args.duration / 101
    for i in range(101):
        if not await _launch_and_run("plymouth", "system-update", f"--progress={i}"):
            logger.error("Failed to talk to Plymouth, did it crash?")
            return

        if not await _launch_and_run(
            "plymouth",
            "display-message",
            f"--text={args.mode}: {i:02}%",
        ):
            logger.error("Failed to talk to Plymouth, did it crash?")
            return
        await asyncio.sleep(sleep_amount)


async def _launch_and_run(command: str, *args: str) -> bool:
    program = await _launch_program(command, *args)
    await program.wait()
    return program.returncode == 0


async def _ask_question(type: str, prompt: str, answer: str, retries=3) -> bool:
    answer = answer.strip()
    has_failed = False
    error_message = "*BZZT* wrong!"
    for _ in range(retries):
        program = await _launch_program(
            "plymouth",
            type,
            f"--prompt={prompt} (Hint: It's {answer})",
            capture_logs=True,
            eat_stdout=False,
        )
        await program.wait()
        if program.returncode != 0 or program.stdout is None:
            return False

        result = (await program.stdout.read()).decode("utf-8", errors="replace")
        if result.strip() == answer:
            break

        # TODO: I'm vaguely trying to replicate Ubuntu's behaviour here, though
        # I'm not actually entirely sure how it's reporting the decrypt
        # failures back to Plymouth and I don't have a spare ubuntu machine on
        # me right now to test it so who knows.
        if not has_failed:
            has_failed = True
            if not await _launch_and_run(
                "plymouth",
                "display-message",
                f"--text={error_message}",
            ):
                return False

    if has_failed:
        # Plymouth messages are stoked in a stack and have to be cleared with
        # the exact text, which is... interesting?
        return await _launch_and_run(
            "plymouth",
            "hide-message",
            f"--text={error_message}",
        )
    return True


async def _launch_program(
    command: str,
    *args: str,
    capture_logs: bool = True,
    eat_stdout: bool = True,
) -> subprocess.Process:
    logger.debug("Running %s %s", command, " ".join(args))

    if capture_logs:
        target = subprocess.PIPE
    else:
        target = subprocess.DEVNULL

    process = await subprocess.create_subprocess_exec(
        command,
        *args,
        stdin=None,
        stdout=target,
        stderr=target,
    )

    if capture_logs:
        if eat_stdout:
            asyncio.create_task(_log_reader(command, process.stdout))
        asyncio.create_task(_log_reader(command, process.stderr))

    return process


async def _launch_plymouthd(args: Args) -> subprocess.Process:
    process_args = ["--no-daemon"]
    kernel_command_line = ["splash"]
    if args.ply_debug:
        process_args.append("--debug")
        if args.ply_debug_file:
            process_args.append(f"--debug-file={args.ply_debug_file}")
        else:
            # This ensures the debug output goes somewhere we can catch it,
            # otherwise Plymouth cheerfully overwrites this process's TTY!
            kernel_command_line.append("plymouth.debug=stream:/dev/stdout")

    if args.ply_boot_log_file:
        process_args.append(f"--boot-log={args.ply_boot_log_file}")
    else:
        process_args.append("--no-boot-log")

    if args.mode != "startup":
        process_args.append(f"--mode={args.mode}")

    if args.theme:
        kernel_command_line.append(f"plymouth.splash={args.theme}")
    if args.scale:
        kernel_command_line.append(f"plymouth.force-scale={args.scale}")

    process_args.append("--kernel-command-line=" + " ".join(kernel_command_line))

    logger.info("Launching plymouthd")

    ply_process = await _launch_program("plymouthd", *process_args)

    async def _wait():
        logger.debug("Waiting for plymouthd to start")
        while True:
            if ply_process.returncode is not None:
                logger.critical(
                    "Failed to boot plymouthd! Exited with error code %d",
                    ply_process.returncode,
                )
                exit(1)
            ping_process = await _launch_program(
                "plymouth",
                "--ping",
                capture_logs=False,
            )
            await ping_process.wait()
            if ping_process.returncode == 0:
                return

    try:
        await asyncio.wait_for(_wait(), timeout=STARTUP_TIMEOUT)
    except TimeoutError:
        logger.critical("Plymouthd failed to come up in time!")
        ply_process.kill()
        exit(1)

    return ply_process


async def _log_reader(name: str, stream: streams.StreamReader | None):
    """
    Ensures that log lines from subprocesses go through the logging system to
    avoid mixed writes
    """
    logger = logging.getLogger(name)

    # I can't be bothered to deal with proving mypy wrong on this one
    if stream is None:
        logger.warning("Can't start logging - stream is None!")
        return

    async for line in stream:
        logger.debug("%s", line.decode(encoding="utf-8", errors="replace").strip())


def _check_root():
    if os.geteuid() != 0:
        logger.critical("Cannot work without effective root!")
        exit(1)


class Args(argparse.Namespace):
    duration: int
    mode: str
    theme: str | None
    scale: int | None
    log_level: str
    ply_debug: bool
    ply_debug_file: str | None
    ply_boot_log_file: str | None
    ask_question: str | None
    ask_password: str | None


def _positive_integer(raw: str) -> int:
    value = int(raw)
    if value <= 0:
        raise ValueError(f"Invalid value {raw}")
    return value


def _setup_args() -> Args:
    parser = argparse.ArgumentParser(
        "plymouth-preview",
        description=__doc__,
        epilog="NOTE: You must run this program as root!",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "duration",
        type=_positive_integer,
        nargs="?",
        default=10,
        help="Number of seconds to display the splash screen",
    )
    parser.add_argument(
        "mode",
        nargs="?",
        default="startup",
        choices=[
            "startup",
            "shutdown",
            "reboot",
            "updates",
            "system-upgrade",
            "firmware-upgrade",
            "system-reset",
        ],
        help="What mode to display the splash screen in",
    )
    parser.add_argument("--theme", help="Theme name to preview")
    parser.add_argument(
        "--scale",
        type=_positive_integer,
        help="Force a scaling factor. Fractional values not supported.",
    )
    parser.add_argument(
        "--log-level",
        default="DEBUG",
        type=lambda s: s.upper(),
        choices=["DEBUG", "INFO", "WARN", "ERROR"],
        help="Set the minimum logging level",
    )
    parser.add_argument(
        "--plymouth-debug",
        action="store_true",
        default=False,
        dest="ply_debug",
        help="Tell plymouthd to output debug logging",
    )
    parser.add_argument(
        "--plymouth-debug-file",
        type=os.path.abspath,
        dest="ply_debug_file",
        help="Tell plymouthd to output debug logging to this file",
    )
    parser.add_argument(
        "--plymouth-boot-log",
        type=os.path.abspath,
        dest="ply_boot_log_file",
        help="Tell plymouthd to output the boot log to this file",
    )
    parser.add_argument(
        "--ask-password",
        dest="ask_password",
        metavar="password",
        nargs="?",
        const="password",
        help="Ask the user for a password during startup",
    )
    parser.add_argument(
        "--ask-question",
        dest="ask_question",
        metavar="answer",
        nargs="?",
        const="answer",
        help="Ask the user a question during startup",
    )

    return parser.parse_args(namespace=Args())


def _setup_logging(level: str) -> None:
    logging.basicConfig(
        format="%(relativeCreated)5.0fms [%(levelname)s] %(name)s: %(message)s",
        level=level,
    )


if __name__ == "__main__":
    main()
