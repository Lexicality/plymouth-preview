#!/usr/bin/env python3
"""
Utility script to make testing plymouth themes easier by emulating the boot
process and ensuring that it actually stops!
"""

from __future__ import annotations

__author__ = "Lexi Robinson <lexi@lexi.org.uk>"
__copyright__ = "Copyright 2025 Lexi Robinson"
__license__ = "GPL-3.0-or-later"
__version__ = "0.0.0"

import argparse
import asyncio
import logging
import os
from asyncio import streams, subprocess

logger = logging.getLogger("plymouth-preview")

STARTUP_TIMEOUT = 2
SHUTDOWN_TIMEOUT = 2


def main() -> None:
    args = _setup_args()
    _setup_logging(args.log_level)
    _check_root()

    asyncio.run(_async_main(args))


async def _run_program_bad(name: str, *args: str) -> None:
    process = await _launch_program(name, *args)
    await process.wait()


async def _async_main(args: Args):
    plymouthd = await _launch_plymouthd(args)
    try:
        await _run_program_bad("plymouth", "--show-splash")
        for i in range(args.duration):
            await _run_program_bad("plymouth", f"--update=test{i}")
            await asyncio.sleep(1)
        await _run_program_bad("plymouth", "--quit")
    finally:
        if plymouthd.returncode is None:
            try:
                logger.info("Waiting for plymouthd to shut down")
                await asyncio.wait_for(plymouthd.wait(), timeout=SHUTDOWN_TIMEOUT)
            except TimeoutError:
                logger.error("Timed out waiting for shutdown!")
                plymouthd.kill()


async def _launch_program(command: str, *args: str) -> subprocess.Process:
    logger.info("Running %s %s", command, " ".join(args))

    process = await subprocess.create_subprocess_exec(
        command,
        *args,
        stdin=None,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )

    asyncio.create_task(_log_reader(command, process.stdout))
    asyncio.create_task(_log_reader(command, process.stderr))

    return process


async def _launch_plymouthd(args: Args) -> subprocess.Process:
    process_args = ["--no-daemon"]
    kernel_command_line = ["splash"]
    if args.ply_debug:
        process_args.append("--debug")
        if args.ply_debug_file:
            process_args.append(f"--debug-file={args.ply_debug_file}")
        else:
            # This ensures the debug output goes somewhere we can catch it,
            # otherwise Plymouth cheerfully overwrites this process's TTY!
            kernel_command_line.append("plymouth.debug=stream:/dev/stdout")

    if args.ply_boot_log_file:
        process_args.append(f"--boot-log={args.ply_boot_log_file}")
    else:
        process_args.append("--no-boot-log")

    process_args.append("--kernel-command-line=" + " ".join(kernel_command_line))

    logger.info("Launching plymouthd")

    ply_process = await _launch_program("plymouthd", *process_args)

    async def _wait():
        logger.debug("Waiting for plymouthd to start")
        while True:
            if ply_process.returncode is not None:
                logger.critical(
                    "Failed to boot plymouthd! Exited with error code %d",
                    ply_process.returncode,
                )
                exit(1)
            ping_process = await subprocess.create_subprocess_exec(
                "plymouth",
                "--ping",
                stdin=None,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            await ping_process.wait()
            if ping_process.returncode == 0:
                return

    try:
        await asyncio.wait_for(_wait(), timeout=STARTUP_TIMEOUT)
    except TimeoutError:
        logger.critical("Plymouthd failed to come up in time!")
        ply_process.kill()
        exit(1)

    return ply_process


async def _log_reader(name: str, stream: streams.StreamReader | None):
    """
    Ensures that log lines from subprocesses go through the logging system to
    avoid mixed writes
    """
    logger = logging.getLogger(name)

    # I can't be bothered to deal with proving mypy wrong on this one
    if stream is None:
        logger.warning("Can't start logging - stream is None!")
        return

    async for line in stream:
        logger.debug("%s", line.decode(encoding="utf-8", errors="replace").strip())


def _check_root():
    if os.geteuid() != 0:
        logger.critical("Cannot work without effective root!")
        exit(1)


class Args(argparse.Namespace):
    duration: int
    log_level: str
    ply_debug: bool
    ply_debug_file: str | None
    ply_boot_log_file: str | None


def _positive_integer(raw: str) -> int:
    value = int(raw)
    if value <= 0:
        raise ValueError(f"Invalid value {raw}")
    return value


def _setup_args() -> Args:
    parser = argparse.ArgumentParser(
        "plymouth-preview",
        description=__doc__,
        epilog="NOTE: You must run this program as root!",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "duration",
        type=_positive_integer,
        nargs="?",
        default=10,
        help="Number of seconds to display the splash screen",
    )
    parser.add_argument(
        "--log-level",
        default="DEBUG",
        type=lambda s: s.upper(),
        choices=["DEBUG", "INFO", "WARN", "ERROR"],
        help="Set the minimum logging level",
    )
    parser.add_argument(
        "--plymouth-debug",
        action="store_true",
        default=False,
        dest="ply_debug",
        help="Tell plymouthd to output debug logging",
    )
    parser.add_argument(
        "--plymouth-debug-file",
        type=os.path.abspath,
        dest="ply_debug_file",
        help="Tell plymouthd to output debug logging to this file",
    )
    parser.add_argument(
        "--plymouth-boot-log",
        type=os.path.abspath,
        dest="ply_boot_log_file",
        help="Tell plymouthd to output the boot log to this file",
    )

    return parser.parse_args(namespace=Args())


def _setup_logging(level: str) -> None:
    logging.basicConfig(
        format="%(relativeCreated)5.0fms [%(levelname)s] %(name)s: %(message)s",
        level=level,
    )


if __name__ == "__main__":
    main()
